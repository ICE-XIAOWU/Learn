# 第二章

### 1. 何为重构?

1. 解释：
   - 重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可视察行为的前提下，提高其可理解性，降低其修改成本。如前面第一章所提到的有名字的重构：“提炼函数（106）、以多态取代条件表达式（272）”等。
   - 重构（动词）：使用一系列重构手法，在不改变软件可视察行为的前提下，调整其结构。
2. 重构的关键：运用大量微小且保持软件行为的步骤，一步步达成大规模的修改（一步步来，不影响代码的运行）。

### 2. 两顶帽子

1. 两顶帽子：把时间分给截然不同的两种行为：添加新功能和重构。添加新功能时，只管添加新功能，不修改其余代码；重构时则不再添加功能，只调整代码的结构。除非发现有遗漏或者绝对必要才修改，例如接口变化等。
   - 在开发的过程中，可能会两个帽子不同的戴，比如添加新功能时发现程序结构改一下，功能会添加得容易很多，则会戴上重构的帽子，程序结构调整之后，则换回原来的帽子。

### 3. 为何重构

1. 改进软件的设计
   - 优秀设计的根本：所有事物和行为在代码中只表述一次。
2. 使软件理解得更容易
3. 帮助找到bug：理解程序结构，了解代码的所作所为。
4. 提高编程速度
   - 内部质量良好的代码可以容易的找出哪里需要修改，如何修改；
   - 设计耐久性假说 ：通过投入精力改善内部设计，增加软件的耐久性，从而可以更长时间地保持开发的快速。

### 4. 何时重构

**三次法则：**第一次做某事时只管去做；第二次做类似的事时会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。

1. 预备性重构：添加新功能更容易
   - 在添加新功能之前，先去查看当前的代码库，看是否需要重构以便让自己的共做更容易。
2. 帮助理解的重构：使代码更易懂
   - 通过重构，把对代码的理解植入代码中，让这份知识保存得更久。
3. 捡垃圾式重构
   - 把需要重构的地方变成垃圾，评判是否容易重构，如果容易重构则立马重构它，否则则记下来，完成当下的任务后再重构它。
   - 野营老话：至少要让营地比你达到时更干净。代码同理。
   - 如果这个垃圾十分庞大，那就每次经过这段代码时都去把它变好一点点。因为每个小的步骤不会破坏代码。
4. 有计划的重构与见机行事的重构
   - 重构并不都是为了弥补过去的错误或者清理肮脏的代码；肮脏的代码必须要重构，但漂亮的代码也需要很多重构。
   - 每次要修改时，首先令修改很容易（警告：这件事有时会很难），然后在进行这次容易的修改 - by Kent Beck。
5. 长期重构
   - 不要让一个团队专门做重构，而是让整个团队达成共识，在未来几周的时间里去逐步解决这个问题，这通常是一个有效的策略。这个策略的好处在于：重构不会破坏代码——每次小的改动之后，整个系统都能正常的工作。
6. 复审代码时的重构
7. 何时不应该重构
   - 当看见一块凌乱的代码，但并不需要修改它，那就不需要去重构它；
   - 如果丑陋的代码能被隐藏在一个API之下，那么可以继续容忍它的丑陋，除非需要去理解它的工作原理；
   - 如果重写比重构容易，选择重写。

### 5. 重构的挑战

1. 生活中很少有晴空万里的好事。
2. 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。
3. 重构的意义并不在于把代码打磨得漂漂亮亮、闪闪发光的，而是纯粹经济角度出发的考量。之所以重构，是因为它能够让我们更快——添加功能更快、修复bug更快。一定要记住这一点，重构是有经济利益驱动的。
4. 持续集成（Continuous Integration， CI ），又称“基于主干开发”：在使用CI时，每个成员至少每天要向主分支集成一次，避免合并难度过大。

### 6. 重构、架构和YAGNI

1. YAGNI（你不会需要它（you aren't going to need it））：一种设计，建议在开发的时候平衡。

### 7. 重构与软件开发进程

1. 重构的第一块基石：自测试代码。应该有一套自测试的代码，且可以频繁的运行它，并在编程过程有错误，会有测试失败。
2. 三大实践：自测试代码、持续集成、重构。彼此之间有着很强的协同效应。
3. 软件开发是一件复杂而微妙的是，涉及人与人之间、人与机器之间的复杂交互。

### 8. 重构与性能

1. 虽然重构可能使软件运行更慢，但它也使软件的性能优化更容易。除了对性能有严格要求的实时系统，其他任何情况下“编写快速软件”的秘密就是：先写出可调优的软件，然后调优它以求获得足够的速度。
2. 编写快速软件的方法：
   - 时间预算法：分解设计时就需要做好预算，给每个组件预先分配一定资源，包括时间与空间的占用。每个组件绝对不能超出自己的预算，就算拥有组件之间调度预配时间的机制也不行。注：该方法通常用于性能要求极高的实时系统。
   - 持续关注法：要求任何程序员在任何时间做任何事时，都要设法保持系统的高性能。
     - 哪怕你完全了解系统，也请实际度量它的性能，不要臆测。臆测会让你学到一些东西，但十有八九你是错的。
     - 一个有趣的事：如果你对大多数程序进行分析，就会发现它把大把时间都耗费在一小半代码身上。如果你一视同仁地优化所有代码，90%的优化工作都是白费劲，因为被你优化的代码大多很少被执行。你只是在白费劲而已。
   - 利用上述的90%统计数据：先编写构造良好的程序，不对性能投以特别的关注，直到进入性能优化阶段，再遵循特定的流程来调优程序性能。

### 9. 重构起源何处

1. 重构是整个软件开发过程的一个关键环节，最早认识到重构重要性的两个人是：Ward Cunningham与Kent Beck，并使用Smalltalk开发了了对应的重构方法以及应用，不断的精炼重构的过程。
2. Ralph Johnson：伊利诺伊大学厄巴纳-香槟分校教授，著名的GOF之一。揭示了重构有助于灵活高效框架的开发。
3. Bill Opdyke：Ralph的博士研究生。从工具构筑者的角度来看待重构以及语义保持的重构。
4. Martin Fowler：在与Kent合作一个项目后，体会到了重构的重要性，并开始去学习以及推广重构，但没有任何一本书能讲解清楚重构，且也没有任何一位专家打算写一本书来讲述，因此上面这些专家的帮助下写下了重构的第一版 。

### 11. 延展阅读

1. 入门教材：《重构手册》- Bill Wake
2. 《重构与模式》- Josh Kerievsky
3. 《数据库重构》- Scott Ambler、Pramod Sadalage
4. 《重构HTML》- Elliotte Rusty Harold
5. 《修改代码的艺术》- Michael Feathers
6. 重构网站：refactoring.com