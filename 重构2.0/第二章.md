# 第二章

### 1. 何为重构?

1. 解释：
   - 重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可视察行为的前提下，提高其可理解性，降低其修改成本。如前面第一章所提到的有名字的重构：“提炼函数（106）、以多态取代条件表达式（272）”等。
   - 重构（动词）：使用一系列重构手法，在不改变软件可视察行为的前提下，调整其结构。
2. 重构的关键：运用大量微小且保持软件行为的步骤，一步步达成大规模的修改（一步步来，不影响代码的运行）。

### 2. 两顶帽子

1. 两顶帽子：把时间分给截然不同的两种行为：添加新功能和重构。添加新功能时，只管添加新功能，不修改其余代码；重构时则不再添加功能，只调整代码的结构。除非发现有遗漏或者绝对必要才修改，例如接口变化等。
   - 在开发的过程中，可能会两个帽子不同的戴，比如添加新功能时发现程序结构改一下，功能会添加得容易很多，则会戴上重构的帽子，程序结构调整之后，则换回原来的帽子。

### 3. 为何重构

1. 改进软件的设计
   - 优秀设计的根本：所有事物和行为在代码中只表述一次。
2. 使软件理解得更容易
3. 帮助找到bug：理解程序结构，了解代码的所作所为。
4. 提高编程速度
   - 内部质量良好的代码可以容易的找出哪里需要修改，如何修改；
   - 设计耐久性假说 ：通过投入精力改善内部设计，增加软件的耐久性，从而可以更长时间地保持开发的快速。

### 4. 何时重构

**三次法则：**第一次做某事时只管去做；第二次做类似的事时会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。

1. 预备性重构：添加新功能更容易
   - 在添加新功能之前，先去查看当前的代码库，看是否需要重构以便让自己的共做更容易。
2. 帮助理解的重构：使代码更易懂
   - 通过重构，把对代码的理解植入代码中，让这份知识保存得更久。
3. 捡垃圾式重构
   - 把需要重构的地方变成垃圾，评判是否容易重构，如果容易重构则立马重构它，否则则记下来，完成当下的任务后再重构它。
   - 野营老话：至少要让营地比你达到时更干净。代码同理。
   - 如果这个垃圾十分庞大，那就每次经过这段代码时都去把它变好一点点。因为每个小的步骤不会破坏代码。
4. 有计划的重构与见机行事的重构
   - 重构并不都是为了弥补过去的错误或者清理肮脏的代码；肮脏的代码必须要重构，但漂亮的代码也需要很多重构。
   - 每次要修改时，首先令修改很容易（警告：这件事有时会很难），然后在进行这次容易的修改 - by Kent Beck。
5. 长期重构
   - 不要让一个团队专门做重构，而是让整个团队达成共识，在未来几周的时间里去逐步解决这个问题，这通常是一个有效的策略。这个策略的好处在于：重构不会破坏代码——每次小的改动之后，整个系统都能正常的工作。
6. 复审代码时的重构
7. 何时不应该重构
   - 当看见一块凌乱的代码，但并不需要修改它，那就不需要去重构它；
   - 如果丑陋的代码能被隐藏在一个API之下，那么可以继续容忍它的丑陋，除非需要去理解它的工作原理；
   - 如果重写比重构容易，选择重写。

### 5. 重构的挑战

1. 生活中很少有晴空万里的好事。
2. 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。
3. 重构的意义并不在于把代码打磨得漂漂亮亮、闪闪发光的，而是纯粹经济角度出发的考量。之所以重构，是因为它能够让我们更快——添加功能更快、修复bug更快。一定要记住这一点，重构是有经济利益驱动的。
4. 持续集成（Continuous Integration， CI ），又称“基于主干开发”：在使用CI时，每个成员至少每天要向主分支集成一次，避免合并难度过大。