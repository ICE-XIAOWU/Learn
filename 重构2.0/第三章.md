# 第三章 代码的坏味道

1. 如果尿布臭了，就换掉它。
2. 没有任何量度规矩比得上见识广博者的直觉。

### 1. 神秘命名（Mysterious Name）

1. 命名是编程中最难的两件事之一。
1. 常用的重构手法：改变函数声明（124）、变量改名（137）、字段改名（244）等。
1. 请注意：一个好的名字能够节省很多猜谜时间。如果你想不出一个好名字，则表明该代码背后很可能潜藏着更深的设计问题。

### 2. 重复代码（Duplicated Code）

1. 如果你在一个以上的地点看到相同的代码结构，那么可以肯定：设法将它们合而为一，程序会变得更好。
2. 重构方法：
   - 提炼函数（106）：同一个类的两个函数含有相同的表达式，想办法让这两个地方都调用被提炼出来的那一段代码。
   - 移动语句（223）：重复的代码只是相似而不是完全相同时，重组顺序，把相似的部分放在一起提炼。
   - 函数上移（350）：重复的代码段位于同一个超类的不同子类中，避免两个子类之间相互调用。

### 3. 过长函数（Long Function）

1. 活得最长、最好的程序，其中的函数都比较短。程序里满是无穷无尽的委托调用。
2. 间接性带来的好处：更好的阐释力、更易于分享、更多的选择。
3. 让小函数易于理解的关键是在于良好的命名。
4. 一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。
   - 可以是一组或一行代码来做这件事。
   - 只要函数名称能够解释其用途，即可做。
   - 关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。
5. 重构手法：
   - 提炼函数（106）：将函数中适合集中在一起的部分。
   - 以查询取代临时变量（178）：如果许多参数和临时变量传递给提炼出来的函数，并导致可读性变差，可以使用以查询取代临时变量的手法来消除。
   - 引入对象（140）、保持对象完整（319）：将过长的参数列表变得更简洁。
   - 以命令取代函数（337）：当以查询取代临时变量（178）、引入对象（140）、保持对象完整（319）手法都使用之后还仍然有大量临时变量和参数时。
   - 分解条件表达式（260）：庞大的switch语句，每个分支可以使用提炼函数变成独立函数的调用。
   - 以多态取代条件表达式（272）：多个switch语句基于同一个条件进行分支选择。
   - 拆分循环（227）：将循环和循环内的代码提炼到一个函数中，发现提炼出的循环很难命名，可能是因为其中做了几件不同的事。这时即可使用拆分循环将其拆分成各自独立的任务。
6. 如何定义需要提炼的代码：寻找注释，它们能够指出代码用途以及实现手法之间的语义距离。就算只有一行代码，如果它需要以注释来说明，那它也值得将它提炼到独立函数中。

### 4. 过长参数列表（Long Parameter List）

1. 重构手法：
   - 以查询取代参数（324）：可以向某个参数发起查询而获得另一个参数的值。
   - 保持对象完整性（319）：从现有的数据结构中抽出很多数据项时，直接传入原来的数据结构。
   - 引入参数对象（140）：几项参数总是同时出现，可以将其合并成一个对象。
   - 移除标记参数（314）：某个参数被用作区分函数行为的标记。
   - 函数组成类（144）：多个函数有同样的几个参数，引入一个类，将共同的参数变成这个类的字段。

### 5. 全局数据（Global Data）

1. 全局数据时最刺鼻的坏味道之一，它的问题在于：从代码库的任何一个角落都可以修改它，且没有任何机制可以探测出到底哪段代码做出了修改。
2. 重构手法：
   - 封装变量（132）：把全局数据用一个函数包装起来。
3. 帕拉塞尔斯的格言：良药与毒药的区别在于剂量。
4. 有少量的全局数据或许无妨，但数量越多，处理的难度就会指数上升。

### 6. 可变数据（Mutable Data）

1. 函数式编程：完全建立在“数据永不改变”的概念基础上：如果要更新一个数据结构，就返回一份新的数据副本，旧数据仍保持不变。
2. 重构手法：
   - 封装变量（132）：将所有数据更新操作都通过很少几个函数进行，使其更容易的监控和演进。
   - 拆分变量（240）：一个变量在不同时候被用于存储不同的东西，拆分为各自不同用途的变量，避免危险的更新操作。
   - 移动语句（223）、提炼函数（106）：将逻辑从处理更新操作的代码中搬移出来，将没有副作用的代码与执行数据更新操作的代码分开。
   - 查询函数、修改函数分离（306）：设计API时，用于确保调用者不会调到有副作用的代码，除非他们真的需要更新数据。
   - 移除设值函数（331）：把设值函数的使用者找出来，看看是否能够缩小其变量作用域。
   - 以查询取代派生变量（248）：如果可变数据的值能在其他地方计算出来（一个特别刺鼻的坏味道）。
   - 函数组合成类（144）、函数组成变换（149）：用于限制需要对变量进行修改的代码量。
   - 将引用对象改为值对象（252）：如果一个变量在其内部结构中包含了数据，通常最好不要直接修改其中数据。

### 7. 发散式变化（Divergent Change）

1. 发散式变化：如果某个模块经常因为不同的原因在不同的方向上发生变化。
2. 如果一个系统在需要修改时，修改不止是修改其中的一处，那么这是一种坏味道的代码。
3. 重构手法：
   - 拆分阶段（154）：发生变化的两个方向自然的形成先后次序时，将两者拆开，通过一个清晰的数据结构进行沟通。
   - 搬移函数（198）：如果两个方向有更多的来回调用，先建立适用的模块，然后使用搬移函数将其逻辑分开。
   - 提炼函数（106）：函数内部混合了两类的处理逻辑，先提炼函数将其分开，再做搬移。
   - 提炼类（182）：如果模块是以类形式定义的。

### 8. 霞弹式修改（Shotgun Surgery）

1. 霞弹式修改：如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霞弹式修改。
2. 重构手法”
   - 搬移函数（198）、搬移字段（207）：将所有需要修改的代码放进同一个模块里。
   - 函数组合成类（144）：如果有很多函数都在操作相似的数据。
   - 函数组合成变换（149）：如果有些函数的功能是转换或者充实数据结构时。
   - 拆分阶段（154）：如果一些函数的输出可以组合后提供给一段专门使用这些计算结果的逻辑时。
   - 内联函数（115）、内联类（186）：把本不该分散的逻辑拽回一处。

### 9. 依恋情结（Feature Envy）

1. 模块化：将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。
2. 依恋情结：一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流。
3. 重构手法：
   - 搬移函数（198）：将需要的数据搬移过去。如果函数中只有一部分受这种依恋之苦，那么就先提炼函数，在搬移函数。
   - 一个函数使用到多个模块的功能：
     - 摆放位置：判断哪个模块拥有的此函数使用的数据最多，然后把这个函数和那些数据摆在一起。
   - 设计模式：策略模式、访问者模式、Self Delegation模式；这些模式的本质是：将总是一起变化的东西放在一块儿，数据和引用这些数据的行为总是一起变化的。如果有例外时，就搬移那些行为，保持变化只在一地发生。

