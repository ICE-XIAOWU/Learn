# 第三章 代码的坏味道

1. 如果尿布臭了，就换掉它。
2. 没有任何量度规矩比得上见识广博者的直觉。

### 1. 神秘命名（Mysterious Name）

1. 命名是编程中最难的两件事之一。
1. 常用的重构手法：改变函数声明（124）、变量改名（137）、字段改名（244）等。
1. 请注意：一个好的名字能够节省很多猜谜时间。如果你想不出一个好名字，则表明该代码背后很可能潜藏着更深的设计问题。

### 2. 重复代码（Duplicated Code）

1. 如果你在一个以上的地点看到相同的代码结构，那么可以肯定：设法将它们合而为一，程序会变得更好。
2. 重构方法：
   - 提炼函数（106）：同一个类的两个函数含有相同的表达式，想办法让这两个地方都调用被提炼出来的那一段代码。
   - 移动语句（223）：重复的代码只是相似而不是完全相同时，重组顺序，把相似的部分放在一起提炼。
   - 函数上移（350）：重复的代码段位于同一个超类的不同子类中，避免两个子类之间相互调用。

### 3. 过长函数（Long Function）

1. 活得最长、最好的程序，其中的函数都比较短。程序里满是无穷无尽的委托调用。
2. 间接性带来的好处：更好的阐释力、更易于分享、更多的选择。
3. 让小函数易于理解的关键是在于良好的命名。
4. 一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。
   - 可以是一组或一行代码来做这件事。
   - 只要函数名称能够解释其用途，即可做。
   - 关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。
5. 重构手法：
   - 提炼函数（106）：将函数中适合集中在一起的部分。
   - 以查询取代临时变量（178）：如果许多参数和临时变量传递给提炼出来的函数，并导致可读性变差，可以使用以查询取代临时变量的手法来消除。
   - 引入对象（140）、保持对象完整（319）：将过长的参数列表变得更简洁。
   - 以命令取代函数（337）：当以查询取代临时变量（178）、引入对象（140）、保持对象完整（319）手法都使用之后还仍然有大量临时变量和参数时。
   - 分解条件表达式（260）：庞大的switch语句，每个分支可以使用提炼函数变成独立函数的调用。
   - 以多态取代条件表达式（272）：多个switch语句基于同一个条件进行分支选择。
   - 拆分循环（227）：将循环和循环内的代码提炼到一个函数中，发现提炼出的循环很难命名，可能是因为其中做了几件不同的事。这时即可使用拆分循环将其拆分成各自独立的任务。
6. 如何定义需要提炼的代码：寻找注释，它们能够指出代码用途以及实现手法之间的语义距离。就算只有一行代码，如果它需要以注释来说明，那它也值得将它提炼到独立函数中。

### 4. 过长参数列表（Long Parameter List）

1. 重构手法：
   - 以查询取代参数（324）：可以向某个参数发起查询而获得另一个参数的值。
   - 保持对象完整性（319）：从现有的数据结构中抽出很多数据项时，直接传入原来的数据结构。
   - 引入参数对象（140）：几项参数总是同时出现，可以将其合并成一个对象。
   - 移除标记参数（314）：某个参数被用作区分函数行为的标记。
   - 函数组成类（144）：多个函数有同样的几个参数，引入一个类，将共同的参数变成这个类的字段。

### 5. 全局数据（Global Data）

1. 全局数据时最刺鼻的坏味道之一，它的问题在于：从代码库的任何一个角落都可以修改它，且没有任何机制可以探测出到底哪段代码做出了修改。
2. 重构手法：
   - 封装变量（132）：把全局数据用一个函数包装起来。
3. 帕拉塞尔斯的格言：良药与毒药的区别在于剂量。
4. 有少量的全局数据或许无妨，但数量越多，处理的难度就会指数上升。

### 6. 可变数据（Mutable Data）

1. 函数式编程：完全建立在“数据永不改变”的概念基础上：如果要更新一个数据结构，就返回一份新的数据副本，旧数据仍保持不变。
2. 重构手法：
   - 封装变量（132）：将所有数据更新操作都通过很少几个函数进行，使其更容易的监控和演进。
   - 拆分变量（240）：一个变量在不同时候被用于存储不同的东西，拆分为各自不同用途的变量，避免危险的更新操作。
   - 移动语句（223）、提炼函数（106）：将逻辑从处理更新操作的代码中搬移出来，将没有副作用的代码与执行数据更新操作的代码分开。
   - 查询函数、修改函数分离（306）：设计API时，用于确保调用者不会调到有副作用的代码，除非他们真的需要更新数据。
   - 移除设值函数（331）：把设值函数的使用者找出来，看看是否能够缩小其变量作用域。
   - 以查询取代派生变量（248）：如果可变数据的值能在其他地方计算出来（一个特别刺鼻的坏味道）。
   - 函数组合成类（144）、函数组成变换（149）：用于限制需要对变量进行修改的代码量。
   - 将引用对象改为值对象（252）：如果一个变量在其内部结构中包含了数据，通常最好不要直接修改其中数据。

### 7. 发散式变化（Divergent Change）

1. 发散式变化：如果某个模块经常因为不同的原因在不同的方向上发生变化。
2. 如果一个系统在需要修改时，修改不止是修改其中的一处，那么这是一种坏味道的代码。
3. 重构手法：
   - 拆分阶段（154）：发生变化的两个方向自然的形成先后次序时，将两者拆开，通过一个清晰的数据结构进行沟通。
   - 搬移函数（198）：如果两个方向有更多的来回调用，先建立适用的模块，然后使用搬移函数将其逻辑分开。
   - 提炼函数（106）：函数内部混合了两类的处理逻辑，先提炼函数将其分开，再做搬移。
   - 提炼类（182）：如果模块是以类形式定义的。

### 8. 霞弹式修改（Shotgun Surgery）

1. 霞弹式修改：如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霞弹式修改。
2. 重构手法”
   - 搬移函数（198）、搬移字段（207）：将所有需要修改的代码放进同一个模块里。
   - 函数组合成类（144）：如果有很多函数都在操作相似的数据。
   - 函数组合成变换（149）：如果有些函数的功能是转换或者充实数据结构时。
   - 拆分阶段（154）：如果一些函数的输出可以组合后提供给一段专门使用这些计算结果的逻辑时。
   - 内联函数（115）、内联类（186）：把本不该分散的逻辑拽回一处。

### 9. 依恋情结（Feature Envy）

1. 模块化：将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。
2. 依恋情结：一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流。
3. 重构手法：
   - 搬移函数（198）：将需要的数据搬移过去。如果函数中只有一部分受这种依恋之苦，那么就先提炼函数，在搬移函数。
   - 一个函数使用到多个模块的功能：
     - 摆放位置：判断哪个模块拥有的此函数使用的数据最多，然后把这个函数和那些数据摆在一起。
   - 设计模式：策略模式、访问者模式、Self Delegation模式；这些模式的本质是：将总是一起变化的东西放在一块儿，数据和引用这些数据的行为总是一起变化的。如果有例外时，就搬移那些行为，保持变化只在一地发生。

### 10. 数据泥团（Data Clumps）- NY

1. 数据泥团：数据项成群结队的在一起，且在很多地方都看见相同的字段。
2. 评判标准：删除众多数据中的一项，如果失去了意义，则应该产生一个新的对象。
3. 重构手法：
   - 提炼类（182）：找出数据以字段形式出现的地方，然后将其提炼到一个独立的对象中。
   - 引入参数对象（140）、保持对象完整（319）：将参数列表缩短，简化函数调用。只要数据泥团用得上新对象的一部分字段，只要使用得上两个以上的字段，就值得这样做。

### 11. 基本类型偏执（Primitive Obsession）- N

1. 重构手法：
   - 以对象取代基本类型（174）：将原本单独存在的数据值替换为对象。
   - 以子类取代类型码（362）、以多态取代条件表达式（272）：如果要替换的数据值是控制条件行为的类型码。

### 12. 重复的Switch（Repeated Switches）- N

1. 重复的switch：指在不同地方反复使用同样的switch逻辑。
2. 重复的switch问题：每当想增加一个新的选择分支时，必须要去找到所有的switch，并逐一更新。
3. 重构手法：
   - 以多态取代条件表达式（272）。

### 13. 循环语句（Loops）

1. 重构手法：
   - 以管道取代循环（231）：使用管道（如filter、map）可以快速的看清被处理的元素以及处理它们的动作。

### 14. 冗赘的元素（Lazy Element）

1. 如果最开始的时候，有一个类或者函数是很有用；又或者是在最开始设计的时候，它会变得很大、很复杂；但在不断的重构时，它变得越来越小，甚至只剩下一个函数，一行？两行？不论是什么原因，这样的程序元素，我们应该请它庄严赴义。
2. 重构手法：
   - 内联函数（115）
   - 内敛类（186）
   - 折叠继承体系（380）

### 15. 夸夸其谈通用性（Speculative Generality）

1. 命名者：Brian Foote。
2. 夸夸其谈通用性：当有人说“噢，我想我们总有一天需要做这事”，并因而企图以各式各样的钩子和特殊情况来处理一些非必要事情。只有所有装置都被用到才值得这样做，如果用不到就不值得，把它搬开。

### 16. 临时字段（Temporary Field）

1. 在字段未被使用的情况下猜测当初设置它的目的，会让人发疯。对象在所有时候都需要它的所有字段。

### 17. 过长的消息链（Message Chains）

1. 消息链：用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象.......
2. 在实际的代码中，看到的可能是一长串取值函数或者一长串临时变量。
3. 重构手法：
   - 隐藏委托关系（189）：在消息链的不同位置采用这种重构手法。好的选择：先观察消息链最终得到的对象是用来干什么的，然后再使用提炼函数将其代码提到一个独立函数中，在运用搬移函数将其推入消息链。

### 18. 中间人（Middle Man）

1. 对象的基本特征之一：封装——对外部世界隐藏其内部细节。但封装往往伴随着委托。
2. 过度委托：例如某个类的接口有一半函数都委托给其他类。
3. 重构手法：
   - 移除中间人（192）：直接和真正的负责人打交道。
   - 内联函数（115）：如果是函数，且只有少数几个时。

### 19. 内幕交易（Insider Trading）

### 20. 过大的类（Large Class）

1. 把多余的东西消化在类内部，如果有个5个百行函数，且之中的代码很多相同，则可以将它们变成5个10行函数或者10个双行函数。

### 21. 异曲同工的类（Alternative Classes With Different Interfaces）

1. 使用类的好处之一：今天使用这个类，未来可以换成使用另一个类。但只有当两个类的接口一致时才可替换。

### 22. 纯数据类（Data Class）

1. 纯数据类：他们拥有一些字段，以及用于访问这些字段的函数，除此之外一无长物。
2. 将处理数据的行为，放在纯数据类中。

### 23. 被拒绝的遗赠（Refused Bequest）

### 24. 注释（Comments）

1. 如果你需要注释来解释一块代码做了什么，试试将其重构，如提炼函数、改变函数声明、引入断言等。
2. 如果你不知道该做什么，这才是注释的良好运行时机。除了用来计述将来的打算之外，注释还可以用来标记你并无十足把握的区域。
3. 当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。
